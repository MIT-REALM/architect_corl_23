"""Define a simulator for the satellite"""
import time  # noqa

import jax
import jax.numpy as jnp
import numpy as np
import matplotlib.pyplot as plt

from architect.design.examples.turtle_stl.tbstl_exogenous_parameters import (
    TBSTLExogenousParameters,
)


@jax.jit
def tbstl_simulate_dt(
    design_params: jnp.ndarray,
    exogenous_sample: jnp.ndarray,
    time_steps: int,
    dt: float,
) -> jnp.ndarray:
    """Simulate the performance of the satellite rendezvous system.

    To make this function pure, we need to pass in all sources of randomness used.

    args:
        design_params: a time_steps * 2 array of design parameters, representing control
            inputs at each step.
        exogenous_sample: (3,) array containing initial states.
                          Can be generated by TBSTLExogenousParameters.sample
        time_steps: the number of steps to simulate
        dt: the duration of each time step
    returns:
        the state trace in a (time_steps, 3) array
    """
    # To enable easier JIT, this simulation will be implemented as a scan.
    # This requires creating an array with the reference states and controls
    # that we will scan over
    planned_trajectory = design_params.reshape(-1, 2)

    # Now create a function that executes a single step of the simulation
    @jax.jit
    def step(current_state, current_plan):
        """Perform a single simulation step

        args:
            current_state: (3,) array of turtlebot states
            current_plan: (2,) array of 2 planned inputs
        returns:
            - (3,) array of next state
            - (3,) array of next state
        """
        # Get the state and control from the plan
        planned_input = current_plan
        v = planned_input[0]
        w = planned_input[1]

        # Update the state
        theta = current_state[2]
        next_state = current_state.at[0].add(dt * v * jnp.cos(theta))
        next_state = next_state.at[1].add(dt * v * jnp.sin(theta))
        next_state = next_state.at[2].add(dt * w)

        return next_state, next_state

    # Simulate by scanning over the plan
    initial_state = exogenous_sample
    state_control_trace: jnp.ndarray
    final_state, state_trace = jax.lax.scan(step, initial_state, planned_trajectory)

    return state_trace


if __name__ == "__main__":
    # Test the simulation
    t_sim = 30.0
    dt = 0.1
    T = int(t_sim // dt)
    planned_trajectory = jnp.zeros((T, 2)) + 1.0

    planned_trajectory = jnp.array(
        np.loadtxt(
            "logs/turtle_stl/all_constraints/solutions/counterexample_guided_0.csv",
            delimiter=",",
        )
    )

    ep = TBSTLExogenousParameters()
    prng_key = jax.random.PRNGKey(0)
    prng_key, subkey = jax.random.split(prng_key)
    start_state = ep.sample(subkey)

    # Burn-in once to activate JIT (if using)
    state_trace_dt = tbstl_simulate_dt(planned_trajectory, start_state, T, dt)

    ax = plt.axes()
    ax.plot(state_trace_dt[:, 0], state_trace_dt[:, 1], "r", label="Trajectory")
    ax.plot(start_state[0], start_state[1], "ko", label="Start")

    # Plot rings for mission spec
    theta = np.linspace(0, 2 * np.pi, 100)
    r_docking = 0.2
    ax.plot(
        r_docking * np.cos(theta),
        r_docking * np.sin(theta),
        "--",
        color="darkgrey",
        label="Docking zone",
    )

    r_min = 0.5
    ax.plot(
        r_min * np.cos(theta),
        r_min * np.sin(theta),
        "--",
        color="green",
        label="Waiting zone",
    )

    r_max = 1.0
    ax.plot(
        r_max * np.cos(theta),
        r_max * np.sin(theta),
        "--",
        color="green",
    )

    ax.set_aspect("equal")
    ax.legend()

    # N_tests = 5
    # sim_time = 0.0
    # for _ in range(N_tests):
    #     start = time.perf_counter()
    #     state_trace = tbstl_simulate_dt(planned_trajectory, start_state, T, dt)
    #     end = time.perf_counter()
    #     sim_time += end - start

    # print(f"DT: ran {N_tests} sims in {sim_time} s. Average {sim_time / N_tests} s")

    plt.show()
