"""Define a simulator for the satellite"""
import numpy as np
import jax.numpy as jnp
import matplotlib.pyplot as plt
from celluloid import Camera
from tqdm import tqdm

from architect.components.dynamics.linear_satellite import (
    linear_satellite_next_state_substeps,
)


def sat_simulate_high_res(
    design_params: jnp.ndarray,
    exogenous_sample: jnp.ndarray,
    time_steps: int,
    dt: float,
    substeps: int,
) -> jnp.ndarray:
    """Simulate the performance of the satellite rendezvous system.

    To make this function pure, we need to pass in all sources of randomness used.

    Returns all subsamples

    args:
        design_params: a (6 * 3 + time_steps * (3 + 6)) array of design parameters.
            The first 6 * 3 values define a gain matrix for state-feedback control
            u = -K(x - x_planned). Each later group of 3 + 6 values is a control input
            and target state at that timestep, defining a trajectory.
        exogenous_sample: (6,) array containing initial states.
                          Can be generated by SatExogenousParameters.sample
        time_steps: the number of steps to simulate
        dt: the duration of each time step
        substeps: how many smaller updates to break this interval into
    returns:
        - the state trace in a (time_steps, 6) array
    """
    # Extract design parameters
    K = design_params[: 6 * 3].reshape(3, 6)
    planned_trajectory = design_params[6 * 3 :].reshape(-1, 3 + 6)

    # No noise for now
    actuation_noise = jnp.zeros(6)

    # Make somewhere to store the results
    state_trace = jnp.zeros((time_steps * substeps, 6))
    current_state = exogenous_sample

    for t in range(0, time_steps * substeps):
        if t % substeps == 0:
            # Get the state and control from the plan
            planned_input = planned_trajectory[int(t / substeps), :3]
            planned_state = planned_trajectory[int(t / substeps), 3:]

            # Compute the control from feedback and planned
            control_input = planned_input - K @ (current_state - planned_state)

        # Update the state
        current_state = linear_satellite_next_state_substeps(
            current_state, control_input, actuation_noise, dt / substeps, 1
        )
        state_trace = state_trace.at[t].set(current_state)

    return state_trace


if __name__ == "__main__":
    # Test the simulation
    t_sim = 200.0
    dt = 2.0
    substeps = 200 // 10
    T = int(t_sim // dt)
    start = jnp.array([13.0, 13.0, 3.0, 1.0, 1.0, -1.0])
    design_params = jnp.array(
        np.loadtxt(
            # "logs/satellite_stl/safety_and_goal_only/design_params_opt.csv",
            "logs/satellite_stl/all_constraints/design_params_opt.csv",
            delimiter=",",
        )
    )

    # Burn-in once to activate JIT (if using)
    state_trace_1 = sat_simulate_high_res(design_params, start, T, dt, substeps)

    ax = plt.axes(projection="3d")

    # Start the animation recording
    camera = Camera(plt.gcf())

    n_frames = 0
    for i in tqdm(range(0, state_trace_1.shape[0], substeps)):
        # # refresh legend if needed
        # if ax.get_legend() is not None:
        #     ax.get_legend().remove()

        ax.plot3D(
            state_trace_1[:i, 0],
            state_trace_1[:i, 1],
            state_trace_1[:i, 2],
            label="Chaser trajectory",
            color="blue",
        )
        ax.plot3D([], [], [], color="darkgrey", label="Speed-limit zone")
        ax.plot3D([], [], [], color="peru", label="Observation zone")
        ax.plot3D(
            state_trace_1[i, 0],
            state_trace_1[i, 1],
            state_trace_1[i, 2],
            "ks",
            label="Chaser",
            markersize=6,
        )
        ax.plot3D(0.0, 0.0, 0.0, "ko", label="Target", markersize=6)
        ax.set_xlabel("$p_x$")
        ax.set_ylabel("$p_y$")
        ax.set_zlabel("$p_z$")
        ax.set_xlim([-18, 18])
        ax.set_ylim([-18, 18])
        ax.set_zlim([-18, 18])

        # Plot sphere
        u, v = (
            np.mgrid[0 : 2 * np.pi : 100j, np.pi / 2 : np.pi / 2 : 100j]  # type: ignore
        )
        x = 2.0 * np.cos(u) * np.sin(v)
        y = 2.0 * np.sin(u) * np.sin(v)
        z = 2.0 * np.cos(v)
        ax.plot_surface(
            x,
            y,
            z,
            edgecolor="darkgrey",
            color="darkgrey",
            alpha=0.2,
            zorder=0,
            rcount=6,
            ccount=6,
        )

        u, v = (
            np.mgrid[0 : 2 * np.pi : 100j, np.pi / 2 : np.pi / 2 : 100j]  # type: ignore
        )
        x = 3.0 * np.cos(u) * np.sin(v)
        y = 3.0 * np.sin(u) * np.sin(v)
        z = 3.0 * np.cos(v)
        ax.plot_surface(
            x,
            y,
            z,
            edgecolor="peru",
            color="peru",
            alpha=0.1,
            zorder=0,
            rcount=6,
            ccount=6,
        )

        # ax.legend(loc="upper right", prop={"size": 16})
        ax.view_init(elev=40.0, azim=130)
        plt.gcf().set_size_inches(12, 12)
        camera.snap()
        n_frames += 1
        # if n_frames > 20:
        #     plt.show()

    # Create the animation
    animation_length = 10.0  # seconds
    ms_per_frame = animation_length * 1000 / n_frames
    animation = camera.animate(interval=ms_per_frame)
    animation.save("sat_mission_2.gif")
